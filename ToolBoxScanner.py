import argparse
import os
import subprocess
import sys
import re
import time
import socket

# ANSI color variables
RED = '\033[0;31m'
YELLOW = '\033[0;33m'
GREEN = '\033[0;32m'
NC = '\033[0m'


def get_elapsed_time():
    return time.time()


def parse_flags():
    parser = argparse.ArgumentParser(description="nmapAutomator Python script")
    parser.add_argument("-H", "--host", type=str,
                        required=True, help="Target IP")
    parser.add_argument("-t", "--type", type=str,
                        required=True, help="Scan type")
    parser.add_argument("-d", "--dns", type=str, help="DNS server")
    parser.add_argument("-o", "--output", type=str, help="Output directory")
    parser.add_argument("-s", "--static-nmap", type=str,
                        help="Static nmap path")
    parser.add_argument(
        "-r", "--remote", action="store_true", help="Remote mode")

    args = parser.parse_args()
    return args


def resolve_dns(dns=None):
    if dns:
        return dns, f"--dns-server={dns}"
    else:
        with open('/etc/resolv.conf') as f:
            for line in f:
                if line.startswith("nameserver"):
                    dns_server = line.split()[1]
                    return dns_server, "--system-dns"
    return None, ""


def get_nmap_path(static_nmap=None):
    if static_nmap:
        if os.path.isfile(static_nmap) and os.access(static_nmap, os.X_OK):
            with subprocess.Popen([static_nmap, "-h"], stdout=subprocess.PIPE) as proc:
                if "Nmap" in proc.stdout.read().decode('utf-8'):
                    return static_nmap
        print(
            f"{RED}Static binary does not appear to be Nmap! Running in Remote mode...{NC}")
        return None
    try:
        return subprocess.check_output(["which", "nmap"]).decode('utf-8').strip()
    except subprocess.CalledProcessError:
        print(
            f"{RED}Nmap is not installed and -s is not used. Running in Remote mode...{NC}")
        return None


def usage():
    print(f"""
{RED}Usage: {os.path.basename(sys.argv[0])} -H/--host <TARGET-IP> -t/--type <TYPE>{NC}
{YELLOW}Optional: [-r/--remote <REMOTE MODE>] [-d/--dns <DNS SERVER>] [-o/--output <OUTPUT DIRECTORY>] [-s/--static-nmap <STATIC NMAP PATH>]{NC}
Scan Types:
{YELLOW}\tNetwork : {NC}Shows all live hosts in the host's network {YELLOW}(~15 seconds){NC}
{YELLOW}\tPort    : {NC}Shows all open ports {YELLOW}(~15 seconds){NC}
{YELLOW}\tScript  : {NC}Runs a script scan on found ports {YELLOW}(~5 minutes){NC}
{YELLOW}\tFull    : {NC}Runs a full range port scan, then runs a script scan on new ports {YELLOW}(~5-10 minutes){NC}
{YELLOW}\tUDP     : {NC}Runs a UDP scan "requires sudo" {YELLOW}(~5 minutes){NC}
{YELLOW}\tVulns   : {NC}Runs CVE scan and nmap Vulns scan on all found ports {YELLOW}(~5-15 minutes){NC}
{YELLOW}\tRecon   : {NC}Suggests recon commands, then prompts to automatically run them
{YELLOW}\tAll     : {NC}Runs all the scans {YELLOW}(~20-30 minutes){NC}
""")
    sys.exit(1)


def header(host, scan_type, dns_server, remote):
    print()
    print(f"{YELLOW}Running a {scan_type} scan on {NC}{host}")

    try:
        url_ip = socket.gethostbyname(host)
        print(f"{YELLOW} with IP {NC}{url_ip}")
    except socket.gaierror:
        print(f".. {RED}Could not resolve IP of {NC}{host}")

    if remote:
        print(f"{YELLOW}Running in Remote mode! Some scans will be limited.{NC}")

    print()


def create_output_dir(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)


def network_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Network_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -sn -T4 -oN {output_file} {host}/24 {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Network Scan is not implemented yet in Remote mode.{NC}")


def port_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Port_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -T4 --max-retries 1 --max-scan-delay 20 --open -oN {
            output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Port Scan is not implemented yet in Remote mode.{NC}")


def script_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Script_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -sC -sV -T4 -oN {output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Script Scan is not implemented yet in Remote mode.{NC}")


def full_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Full_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -p- -T4 --max-retries 1 --max-scan-delay 20 --open -oN {
            output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Full Scan is not implemented yet in Remote mode.{NC}")


def udp_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"UDP_{host}.nmap")

    if not remote:
        cmd = f"sudo {nmap_path} -sU -T4 --max-retries 1 --max-scan-delay 20 --open -oN {
            output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}UDP Scan is not implemented yet in Remote mode.{NC}")


def vulns_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Vulns_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} --script vuln -T4 -oN {output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Vulns Scan is not implemented yet in Remote mode.{NC}")


def recon_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Recon_{host}.nmap")
    
    if not remote:
        # Basic recon commands - can be extended with more specific tools and techniques
        cmd = f"{nmap_path} -sC -sV -T4 -oN {output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
        
        # Additional recon suggestions
        print(f"{YELLOW}Running additional reconnaissance...{NC}")
        recon_cmds = [
            f"{nmap_path} --script=banner -p 80,443 -oN {output_file} {host}",
            f"{nmap_path} --script=http-title -p 80,443 -oN {output_file} {host}",
            f"{nmap_path} --script=ftp-anon -p 21 -oN {output_file} {host}"
        ]
        
        for cmd in recon_cmds:
            subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Recon Scan is not implemented yet.{NC}")


def all_scans(host, dns_string, nmap_path, remote):
    network_scan(host, dns_string, nmap_path, remote)
    port_scan(host, dns_string, nmap_path, remote)
    script_scan(host, dns_string, nmap_path, remote)
    full_scan(host, dns_string, nmap_path, remote)
    udp_scan(host, dns_string, nmap_path, remote)
    vulns_scan(host, dns_string, nmap_path, remote)
    recon_scan(host, dns_string, nmap_path, remote)


def main():
    args = parse_flags()
    elapsed_start = get_elapsed_time()

    host = args.host
    scan_type = args.type
    dns_server, dns_string = resolve_dns(args.dns)
    nmap_path = get_nmap_path(args.static_nmap)
    remote = args.remote

    if not nmap_path and not remote:
        usage()
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Recon_{host}.nmap")
    
    if not remote:
        # Basic recon commands - can be extended with more specific tools and techniques
        cmd = f"{nmap_path} -sC -sV -T4 -oN {output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
        
        # Additional recon suggestions
        print(f"{YELLOW}Running additional reconnaissance...{NC}")
        recon_cmds = [
            f"{nmap_path} --script=banner -p 80,443 -oN {output_file} {host}",
            f"{nmap_path} --script=http-title -p 80,443 -oN {output_file} {host}",
            f"{nmap_path} --script=ftp-anon -p 21 -oN {output_file} {host}"
        ]
        
        for cmd in recon_cmds:
            subprocess.run(cmd, shell=True)
    else:
        header(host, scan_type, dns_server, remote)

    if scan_type.lower() == "network":
        network_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "port":
        port_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "script":
        script_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "full":
        full_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "udp":
        udp_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "vulns":
        vulns_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "recon":
        recon_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "all":
        all_scans(host, dns_string, nmap_path, remote)
    else:
        print(f"{RED}Unknown scan type: {scan_type}{NC}")
        usage()

    elapsed_end = get_elapsed_time()
    print(f"Elapsed time: {elapsed_end - elapsed_start:.2f} seconds")


if __name__ == "__main__":
    main()
