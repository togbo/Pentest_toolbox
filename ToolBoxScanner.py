import argparse
import os
import subprocess
import sys
import re
import time
import socket

# ANSI color variables
RED = '\033[0;31m'
YELLOW = '\033[0;33m'
GREEN = '\033[0;32m'
NC = '\033[0m'

def get_elapsed_time():
    return time.time()

def parse_flags():
    parser = argparse.ArgumentParser(description="ToolBoxScanner Python script")
    parser.add_argument("-H", "--host", type=str, required=True, help="Target IP or URL")
    parser.add_argument("-t", "--type", type=str, required=True, help="Scan type")
    parser.add_argument("-d", "--dns", type=str, help="DNS server")
    parser.add_argument("-o", "--output", type=str, help="Output directory")
    parser.add_argument("-s", "--static-nmap", type=str, help="Static nmap path")
    parser.add_argument("-r", "--remote", action="store_true", help="Remote mode")
    args = parser.parse_args()
    return args


def resolve_dns(dns=None):
    if dns:
        return dns, f"--dns-server={dns}"
    else:
        with open('/etc/resolv.conf') as f:
            for line in f:
                if line.startswith("nameserver"):
                    dns_server = line.split()[1]
                    return dns_server, "--system-dns"
    return None, ""


def get_nmap_path(static_nmap=None):
    if static_nmap:
        if os.path.isfile(static_nmap) and os.access(static_nmap, os.X_OK):
            with subprocess.Popen([static_nmap, "-h"], stdout=subprocess.PIPE) as proc:
                if "Nmap" in proc.stdout.read().decode('utf-8'):
                    return static_nmap
        print(f"{RED}Static binary does not appear to be Nmap! Running in Remote mode...{NC}")
        return None
    try:
        return subprocess.check_output(["which", "nmap"]).decode('utf-8').strip()
    except subprocess.CalledProcessError:
        print(f"{RED}Nmap is not installed and -s is not used. Running in Remote mode...{NC}")
        return None


def usage():
    print(f"""
{RED}Usage: {os.path.basename(sys.argv[0])} -H/--host <TARGET-IP or URL> -t/--type <TYPE>{NC}
{YELLOW}Optional: [-r/--remote <REMOTE MODE>] [-d/--dns <DNS SERVER>] [-o/--output <OUTPUT DIRECTORY>] [-s/--static-nmap <STATIC NMAP PATH>]{NC}
Scan Types:
{YELLOW}\tNetwork : {NC}Shows all live hosts in the host's network {YELLOW}(~15 seconds){NC}
{YELLOW}\tPort    : {NC}Shows all open ports {YELLOW}(~15 seconds){NC}
{YELLOW}\tScript  : {NC}Runs a script scan on found ports {YELLOW}(~5 minutes){NC}
{YELLOW}\tFull    : {NC}Runs a full range port scan, then runs a script scan on new ports {YELLOW}(~5-10 minutes){NC}
{YELLOW}\tUDP     : {NC}Runs a UDP scan "requires sudo" {YELLOW}(~5 minutes){NC}
{YELLOW}\tVulns   : {NC}Runs CVE scan and nmap Vulns scan on all found ports {YELLOW}(~5-15 minutes){NC}
{YELLOW}\tRecon   : {NC}Suggests recon commands, then prompts to automatically run them
{YELLOW}\tAll     : {NC}Runs all the scans {YELLOW}(~20-30 minutes){NC}
{YELLOW}\tWeb     : {NC}Runs web vulnerability scans using Nikto and SQLMap
""")
    sys.exit(1)


def header(host, scan_type, dns_server, remote):
    print()
    print(f"{YELLOW}Running a {scan_type} scan on {NC}{host}")
    try:
        url_ip = socket.gethostbyname(host)
        print(f"{YELLOW} with IP {NC}{url_ip}")
    except socket.gaierror:
        print(f".. {RED}Could not resolve IP of {NC}{host}")

    if remote:
        print(f"{YELLOW}Running in Remote mode! Some scans will be limited.{NC}")
    print()


def create_output_dir(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)


def network_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Network_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -sn -T4 -oN {output_file} {host}/24 {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Network Scan is not implemented yet in Remote mode.{NC}")


def port_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Port_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -T4 --max-retries 1 --max-scan-delay 20 --open -oN {output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Port Scan is not implemented yet in Remote mode.{NC}")


def script_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Script_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -sC -sV -T4 -oN {output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Script Scan is not implemented yet in Remote mode.{NC}")


def full_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Full_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -p- -T4 --max-retries 1 --max-scan-delay 20 --open -oN {output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Full Scan is not implemented yet in Remote mode.{NC}")


def udp_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"UDP_{host}.nmap")

    if not remote:
        cmd = f"sudo {nmap_path} -sU -T4 --max-retries 1 --max-scan-delay 20 --open -oN {output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}UDP Scan is not implemented yet in Remote mode.{NC}")


def vulns_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Vulns_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} --script vuln -T4 -oN {output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Vulns Scan is not implemented yet in Remote mode.{NC}")


def recon_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Recon_{host}.nmap")
    
    if not remote:
        # Basic recon commands - can be extended with more specific tools and techniques
        cmd = f"{nmap_path} -sC -sV -T4 -oN {output_file} {host} {dns_string}"
        subprocess.run(cmd, shell=True)
        
        # Additional recon suggestions
        print(f"{YELLOW}Running additional reconnaissance...{NC}")
        recon_cmds = [
            f"{nmap_path} --script=banner -p 80,443 -oN {output_file} {host}",
            f"{nmap_path} --script=http-title -p 80,443 -oN {output_file} {host}",
            f"{nmap_path} --script=ftp-anon -p 21 -oN {output_file} {host}"
        ]
        
        for cmd in recon_cmds:
            subprocess.run(cmd, shell=True)
    else:
        print(f"{YELLOW}Recon Scan is not implemented yet in Remote mode.{NC}")


def all_scans(host, dns_string, nmap_path, remote):
    network_scan(host, dns_string, nmap_path, remote)
    port_scan(host, dns_string, nmap_path, remote)
    script_scan(host, dns_string, nmap_path, remote)
    full_scan(host, dns_string, nmap_path, remote)
    udp_scan(host, dns_string, nmap_path, remote)
    vulns_scan(host, dns_string, nmap_path, remote)
    recon_scan(host, dns_string, nmap_path, remote)


def scan_with_nikto(target_url, report_file):
    command = f'nikto -h {target_url} -o {report_file} -Format txt'
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        if result.returncode == 0:
            print(f"{GREEN}Scan Nikto terminé avec succès. Rapport enregistré dans {report_file}{NC}")
        else:
            print(f"{RED}Erreur lors du scan Nikto : {result.stderr}{NC}")
    except Exception as e:
        print(f"{RED}Une erreur est survenue lors du scan Nikto : {e}{NC}")


def scan_with_sqlmap(target_url, report_dir):
    command = f'sqlmap -u {target_url} --batch --output-dir={report_dir}'
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        if result.returncode == 0:
            print(f"{GREEN}Scan SQLMap terminé avec succès. Rapports enregistrés dans {report_dir}{NC}")
        else:
            print(f"{RED}Erreur lors du scan SQLMap : {result.stderr}{NC}")
    except Exception as e:
        print(f"{RED}Une erreur est survenue lors du scan SQLMap : {e}{NC}")


def generate_global_report(nikto_report_file, sqlmap_report_dir, global_report_file):
    try:
        with open(global_report_file, 'w') as report:
            report.write("=== Rapport de scan Nikto ===\n")
            with open(nikto_report_file, 'r') as nikto_report:
                report.write(nikto_report.read())

            report.write("\n\n=== Rapports de scan SQLMap ===\n")
            report.write(f"Consultez le répertoire {sqlmap_report_dir} pour les rapports SQLMap.")
        
        print(f"{GREEN}Rapport global généré : {global_report_file}{NC}")
    except Exception as e:
        print(f"{RED}Une erreur est survenue lors de la génération du rapport global : {e}{NC}")


def web_scan(host, output_dir):
    create_output_dir(output_dir)
    nikto_report_file = os.path.join(output_dir, 'nikto_scan_report.txt')
    sqlmap_report_dir = os.path.join(output_dir, 'sqlmap_scan_report')
    global_report_file = os.path.join(output_dir, 'global_security_report.txt')

    scan_with_nikto(host, nikto_report_file)
    scan_with_sqlmap(host, sqlmap_report_dir)
    generate_global_report(nikto_report_file, sqlmap_report_dir, global_report_file)


def main():
    args = parse_flags()
    elapsed_start = get_elapsed_time()

    host = args.host
    scan_type = args.type
    dns_server, dns_string = resolve_dns(args.dns)
    nmap_path = get_nmap_path(args.static_nmap)
    remote = args.remote

    if not nmap_path and not remote:
        usage()

    output_dir = args.output if args.output else "nmap"
    create_output_dir(output_dir)

    header(host, scan_type, dns_server, remote)

    if scan_type.lower() == "network":
        network_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "port":
        port_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "script":
        script_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "full":
        full_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "udp":
        udp_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "vulns":
        vulns_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "recon":
        recon_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "all":
        all_scans(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "web":
        web_scan(host, output_dir)
    else:
        print(f"{RED}Unknown scan type: {scan_type}{NC}")
        usage()

    elapsed_end = get_elapsed_time()
    print(f"{GREEN}Elapsed time: {elapsed_end - elapsed_start:.2f} seconds{NC}")


if __name__ == "__main__":
    main()
