import argparse
import os
import subprocess
import sys
import re
from tqdm import tqdm
import time
import socket
from colorama import init, Fore, Style

# Initialize Colorama for colored output
init(autoreset=True)

# ANSI color variables
RED = Fore.RED
YELLOW = Fore.YELLOW
GREEN = Fore.GREEN
NC = Style.RESET_ALL  # Reset color

def get_elapsed_time():
    return time.time()

def parse_flags():
    parser = argparse.ArgumentParser(description="ToolBoxScanner Python script")
    parser.add_argument("-H", "--host", type=str, required=True, help="Target IP or URL")
    parser.add_argument("-t", "--type", type=str, required=True, help="Scan type")
    parser.add_argument("-d", "--dns", type=str, help="DNS server")
    parser.add_argument("-o", "--output", type=str, help="Output directory")
    parser.add_argument("-s", "--static-nmap", type=str, help="Static nmap path")
    parser.add_argument("-r", "--remote", action="store_true", help="Remote mode")
    args = parser.parse_args()
    return args

def run_command_with_progress(cmd, total_lines_estimate=30):
    try:
        # Initialize progress bar with an estimated number of lines
        with tqdm(total=total_lines_estimate, desc="Scan Progress", unit="%") as pbar:
            # Run the command using Popen to capture real-time output
            process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            # Read stdout and update progress bar
            for line in iter(process.stdout.readline, ''):
                print(GREEN + line, end='')  # Print to terminal in green
                pbar.update(1)               # Update progress bar

            # Read stderr and update progress bar
            for line in iter(process.stderr.readline, ''):
                print(RED + line, end='')    # Print errors to terminal in red
                pbar.update(1)               # Update progress bar

            # Wait for the process to finish
            process.stdout.close()
            process.stderr.close()
            process.wait()

            if process.returncode != 0:
                print(f"{RED}Error executing command: {cmd}{NC}")

    except Exception as e:
        print(f"{RED}An error occurred: {e}{NC}")


def resolve_dns(dns=None):
    if dns:
        return dns, f"--dns-server={dns}"
    else:
        with open('/etc/resolv.conf') as f:
            for line in f:
                if line.startswith("nameserver"):
                    dns_server = line.split()[1]
                    return dns_server, "--system-dns"
    return None, ""

def get_nmap_path(static_nmap=None):
    if static_nmap:
        if os.path.isfile(static_nmap) and os.access(static_nmap, os.X_OK):
            with subprocess.Popen([static_nmap, "-h"], stdout=subprocess.PIPE) as proc:
                if "Nmap" in proc.stdout.read().decode('utf-8'):
                    return static_nmap
        print(f"{RED}Static binary does not appear to be Nmap! Running in Remote mode...{NC}")
        return None
    try:
        return subprocess.check_output(["which", "nmap"]).decode('utf-8').strip()
    except subprocess.CalledProcessError:
        print(f"{RED}Nmap is not installed and -s is not used. Running in Remote mode...{NC}")
        return None

def usage():
    print(f"""
{RED}Usage: {os.path.basename(sys.argv[0])} -H/--host <TARGET-IP or URL> -t/--type <TYPE>{NC}
{YELLOW}Optional: [-r/--remote <REMOTE MODE>] [-d/--dns <DNS SERVER>] [-o/--output <OUTPUT DIRECTORY>] [-s/--static-nmap <STATIC NMAP PATH>]{NC}
Scan Types:
{YELLOW}\tNetwork : {NC}Shows all live hosts in the host's network {YELLOW}(~15 seconds){NC}
{YELLOW}\tPort    : {NC}Shows all open ports {YELLOW}(~15 seconds){NC}
{YELLOW}\tScript  : {NC}Runs a script scan on found ports {YELLOW}(~5 minutes){NC}
{YELLOW}\tFull    : {NC}Runs a full range port scan, then runs a script scan on new ports {YELLOW}(~5-10 minutes){NC}
{YELLOW}\tUDP     : {NC}Runs a UDP scan "requires sudo" {YELLOW}(~5 minutes){NC}
{YELLOW}\tVulns   : {NC}Runs CVE scan and nmap Vulns scan on all found ports {YELLOW}(~5-15 minutes){NC}
{YELLOW}\tRecon   : {NC}Suggests recon commands, then prompts to automatically run them
{YELLOW}\tAll     : {NC}Runs all the scans {YELLOW}(~20-30 minutes){NC}
{YELLOW}\tWeb     : {NC}Runs web vulnerability scans using Nikto and SQLMap(~10-30 minutes){NC}
""")
    sys.exit(1)

def header(host, scan_type, dns_server, remote):
    print()
    print(f"{YELLOW}Running a {scan_type} scan on {NC}{host}")
    try:
        url_ip = socket.gethostbyname(host)
        print(f"{YELLOW} with IP {NC}{url_ip}")
    except socket.gaierror:
        print(f".. {RED}Could not resolve IP of {NC}{host}")

    if remote:
        print(f"{YELLOW}Running in Remote mode! Some scans will be limited.{NC}")
    print()

def create_output_dir(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)

def network_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Network_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -sn -T4 -oN {output_file} {host}/24 {dns_string}"
        run_command_with_progress(cmd)
    else:
        print(f"{YELLOW}Network Scan is not implemented yet in Remote mode.{NC}")

def port_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Port_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -T4 --max-retries 1 --max-scan-delay 20 --open -oN {output_file} {host} {dns_string}"
        run_command_with_progress(cmd)
    else:
        print(f"{YELLOW}Port Scan is not implemented yet in Remote mode.{NC}")

def script_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Script_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -sC -sV -T4 -oN {output_file} {host} {dns_string}"
        run_command_with_progress(cmd)
    else:
        print(f"{YELLOW}Script Scan is not implemented yet in Remote mode.{NC}")

def full_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Full_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} -p- -T4 --max-retries 1 --max-scan-delay 20 --open -oN {output_file} {host} {dns_string}"
        run_command_with_progress(cmd)
    else:
        print(f"{YELLOW}Full Scan is not implemented yet in Remote mode.{NC}")

def udp_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"UDP_{host}.nmap")

    if not remote:
        cmd = f"sudo {nmap_path} -sU -T4 --max-retries 1 --max-scan-delay 20 --open -oN {output_file} {host} {dns_string}"
        run_command_with_progress(cmd)
    else:
        print(f"{YELLOW}UDP Scan is not implemented yet in Remote mode.{NC}")


def vulns_scan(host, dns_string, nmap_path, remote):
    output_dir = os.path.join("nmap")
    create_output_dir(output_dir)
    output_file = os.path.join(output_dir, f"Vulns_{host}.nmap")

    if not remote:
        cmd = f"{nmap_path} --script vuln -T4 -oN {output_file} {host} {dns_string}"
        run_command_with_progress(cmd)
    else:
        print(f"{YELLOW}Vulns Scan is not implemented yet in Remote mode.{NC}")


def recon_scan(host, dns_string, nmap_path, remote):
    print(f"{YELLOW}Recon Scan is not implemented yet. Please check back later.{NC}")


def web_scan(host, dns_string, remote):
    output_dir = os.path.join("web")
    create_output_dir(output_dir)
    
    nikto_output_file = os.path.join(output_dir, f"Nikto_{host}.txt")
    sqlmap_output_file = os.path.join(output_dir, f"SQLMap_{host}.txt")

    print(f"{YELLOW}Running Nikto scan on {host}{NC}")
    nikto_cmd = f"nikto -host {host} -output {nikto_output_file}"
    run_command_with_progress(nikto_cmd)

    print(f"{YELLOW}Running SQLMap scan on {host}{NC}")
    sqlmap_cmd = f"sqlmap -u {host} --batch --output-dir={output_dir}"
    run_command_with_progress(sqlmap_cmd)

def main():
    args = parse_flags()

    host = args.host
    scan_type = args.type
    dns = args.dns
    output_dir = args.output
    static_nmap = args.static_nmap
    remote = args.remote

    dns_server, dns_string = resolve_dns(dns)

    if output_dir:
        create_output_dir(output_dir)
        os.chdir(output_dir)

    nmap_path = get_nmap_path(static_nmap)
    if nmap_path is None:
        remote = True

    header(host, scan_type, dns_server, remote)

    if scan_type.lower() == "network":
        network_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "port":
        port_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "script":
        script_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "full":
        full_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "udp":
        udp_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "vulns":
        vulns_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "recon":
        recon_scan(host, dns_string, nmap_path, remote)
    elif scan_type.lower() == "web":
        web_scan(host, dns_string, remote)
    elif scan_type.lower() == "all":
        network_scan(host, dns_string, nmap_path, remote)
        port_scan(host, dns_string, nmap_path, remote)
        script_scan(host, dns_string, nmap_path, remote)
        full_scan(host, dns_string, nmap_path, remote)
        udp_scan(host, dns_string, nmap_path, remote)
        vulns_scan(host, dns_string, nmap_path, remote)
        web_scan(host, dns_string, remote)
    else:
        usage()

if __name__ == "__main__":
    start_time = get_elapsed_time()
    main()
    elapsed_time = time.time() - start_time
    print(f"{YELLOW}Elapsed time: {elapsed_time:.2f} seconds{NC}")
